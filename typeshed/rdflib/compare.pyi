from rdflib.graph import ConjunctiveGraph, Graph
from rdflib.term import Node, URIRef
from typing import Any, Callable, Dict, List, Optional, Tuple, Union

class _runtime:
    label: Any
    def __init__(self, label) -> None: ...
    def __call__(self, f): ...

class _call_count:
    label: Any
    def __init__(self, label) -> None: ...
    def __call__(self, f): ...

class IsomorphicGraph(ConjunctiveGraph):
    def __init__(self, **kwargs) -> None: ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __hash__(self): ...
    def graph_digest(self, stats: Any | None = ...): ...
    def internal_hash(self, stats: Any | None = ...): ...
HashFunc = Callable[[str], int]
ColorItem = Tuple[Union[int, str], URIRef, Union[int, str]]
ColorItemTuple = Tuple[ColorItem, ...]
HashCache = Optional[Dict[ColorItemTuple, str]]
Stats = Dict[str, Union[int, str]]

class Color:
    color: Any
    nodes: Any
    hashfunc: Any
    def __init__(self, nodes: List[Node], hashfunc: HashFunc, color: ColorItemTuple = ..., hash_cache: HashCache = ...) -> None: ...
    def key(self): ...
    def hash_color(self, color: Optional[Tuple[ColorItem, ...]] = ...) -> str: ...
    def distinguish(self, W: Color, graph: Graph): ...
    def discrete(self): ...
    def copy(self): ...

class _TripleCanonicalizer:
    graph: Any
    hashfunc: Any
    def __init__(self, graph: Graph, hashfunc: _HashT = ...): ...
    def to_hash(self, stats: Optional[Stats] = ...): ...
    def canonical_triples(self, stats: Optional[Stats] = ...): ...

def to_isomorphic(graph): ...
def isomorphic(graph1, graph2): ...
def to_canonical_graph(g1, stats: Any | None = ...): ...
def graph_diff(g1, g2): ...
def similar(g1, g2): ...
