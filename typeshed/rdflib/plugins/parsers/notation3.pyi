from rdflib.parser import Parser
from typing import Any

def splitFragP(uriref, punct: int = ...): ...
def join(here, there): ...
def base(): ...
List_NS = RDF_NS_URI

def runNamespace(): ...
def uniqueURI(): ...
N3_forSome_URI = forSomeSym
N3_forAll_URI = forAllSym

class SinkParser:
    lines: int
    startOfLine: int
    keywords: Any
    keywordsSet: int
    turtle: Any
    string_delimiters: Any
    def __init__(self, store, openFormula: Any | None = ..., thisDoc: str = ..., baseURI: Any | None = ..., genPrefix: str = ..., why: Any | None = ..., turtle: bool = ...) -> None: ...
    def here(self, i): ...
    def formula(self): ...
    def loadStream(self, stream): ...
    def loadBuf(self, buf): ...
    def feed(self, octets) -> None: ...
    def directiveOrStatement(self, argstr, h): ...
    def tok(self, tok, argstr, i, colon: bool = ...): ...
    def sparqlTok(self, tok, argstr, i): ...
    def directive(self, argstr, i): ...
    def sparqlDirective(self, argstr, i): ...
    def bind(self, qn, uri) -> None: ...
    def setKeywords(self, k) -> None: ...
    def startDoc(self) -> None: ...
    def endDoc(self): ...
    def makeStatement(self, quadruple) -> None: ...
    def statement(self, argstr, i): ...
    def subject(self, argstr, i, res): ...
    def verb(self, argstr, i, res): ...
    def prop(self, argstr, i, res): ...
    def item(self, argstr, i, res): ...
    def blankNode(self, uri: Any | None = ...): ...
    def path(self, argstr, i, res): ...
    def anonymousNode(self, ln): ...
    def node(self, argstr, i, res, subjectAlready: Any | None = ...): ...
    def property_list(self, argstr, i, subj): ...
    def commaSeparatedList(self, argstr, j, res, what): ...
    def objectList(self, argstr, i, res): ...
    def checkDot(self, argstr, i): ...
    def uri_ref2(self, argstr, i, res): ...
    def skipSpace(self, argstr, i): ...
    def variable(self, argstr, i, res): ...
    def bareWord(self, argstr, i, res): ...
    def qname(self, argstr, i, res): ...
    def object(self, argstr, i, res): ...
    def nodeOrLiteral(self, argstr, i, res): ...
    def uriOf(self, sym): ...
    def strconst(self, argstr, i, delim): ...
    def uEscape(self, argstr, i, startline): ...
    def UEscape(self, argstr, i, startline): ...
    def BadSyntax(self, argstr, i, msg) -> None: ...

class BadSyntax(SyntaxError):
    lines: Any
    def __init__(self, uri, lines, argstr, i, why) -> None: ...
    @property
    def message(self): ...

class Formula:
    number: int
    uuid: Any
    counter: int
    existentials: Any
    universals: Any
    quotedgraph: Any
    def __init__(self, parent) -> None: ...
    def id(self): ...
    def newBlankNode(self, uri: Any | None = ..., why: Any | None = ...): ...
    def newUniversal(self, uri, why: Any | None = ...): ...
    def declareExistential(self, x) -> None: ...
    def close(self): ...

class RDFSink:
    rootFormula: Any
    uuid: Any
    counter: int
    graph: Any
    def __init__(self, graph) -> None: ...
    def newFormula(self): ...
    def newGraph(self, identifier): ...
    def newSymbol(self, *args): ...
    def newBlankNode(self, arg: Any | None = ..., uri: Any | None = ..., why: Any | None = ...): ...
    def newLiteral(self, s, dt, lang): ...
    def newList(self, n, f): ...
    def newSet(self, *args): ...
    def setDefaultNamespace(self, *args): ...
    def makeStatement(self, quadruple, why: Any | None = ...) -> None: ...
    def normalise(self, f, n): ...
    def intern(self, something): ...
    def bind(self, pfx, uri) -> None: ...
    def startDoc(self, formula) -> None: ...
    def endDoc(self, formula) -> None: ...

def hexify(ustr): ...

class TurtleParser(Parser):
    def __init__(self) -> None: ...
    def parse(self, source, graph, encoding: str = ..., turtle: bool = ...) -> None: ...

class N3Parser(TurtleParser):
    def __init__(self) -> None: ...
    def parse(self, source, graph, encoding: str = ...) -> None: ...
