import pathlib
from rdflib import query
from rdflib.namespace import NamespaceManager
from rdflib.paths import Path
from rdflib.store import Store
from rdflib.term import BNode, Node, URIRef
from typing import Any, Generator, IO, Iterable, Optional, Tuple, Type, Union, overload, Iterator

ContextNode = Union[BNode, URIRef]
DatasetQuad = Tuple[Node, URIRef, Node, Optional[ContextNode]]

class Graph(Node):
    base: Any
    context_aware: bool
    formula_aware: bool
    default_union: bool
    def __init__(self, store: Union[Store, str] = ..., identifier: Optional[Union[Node, str]] = ..., namespace_manager: Optional[NamespaceManager] = ..., base: Optional[str] = ...) -> None: ...
    store: Any
    identifier: Any
    namespace_manager: Any
    def toPython(self): ...
    def destroy(self, configuration): ...
    def commit(self): ...
    def rollback(self): ...
    def open(self, configuration, create: bool = ...): ...
    def close(self, commit_pending_transaction: bool = ...): ...
    def add(self, triple: Tuple[Node, Node, Node]): ...
    def addN(self, quads: Iterable[Tuple[Node, Node, Node, Any]]): ...
    def remove(self, triple): ...
    def triples(self, triple: Tuple[Optional[Node], Union[None, Path, Node], Optional[Node]]): ...
    def __getitem__(self, item): ...
    def __len__(self): ...
    def __iter__(self): ...
    def __contains__(self, triple): ...
    def __hash__(self): ...
    def __cmp__(self, other): ...
    def __eq__(self, other): ...
    def __lt__(self, other): ...
    def __le__(self, other): ...
    def __gt__(self, other): ...
    def __ge__(self, other): ...
    def __iadd__(self, other): ...
    def __isub__(self, other): ...
    def __add__(self, other): ...
    def __mul__(self, other): ...
    def __sub__(self, other): ...
    def __xor__(self, other): ...
    __or__: Any
    __and__: Any
    def set(self, triple): ...
    def subjects(self, predicate: Any | None = ..., object: Any | None = ...) -> Iterator[Node]: ...
    def predicates(self, subject: Any | None = ..., object: Any | None = ...) -> Iterator[Node]: ...
    def objects(self, subject: Any | None = ..., predicate: Any | None = ...) -> Iterator[Node]: ...
    def subject_predicates(self, object: Any | None = ...) -> Generator[Any, None, None]: ...
    def subject_objects(self, predicate: Any | None = ...) -> Generator[Any, None, None]: ...
    def predicate_objects(self, subject: Any | None = ...) -> Generator[Any, None, None]: ...
    def triples_choices(self, triple, context: Any | None = ...) -> Generator[Any, None, None]: ...
    def value(self, subject: Any | None = ..., predicate=..., object: Any | None = ..., default: Any | None = ..., any: bool = ...): ...
    def label(self, subject, default: str = ...): ...
    def preferredLabel(self, subject, lang: Any | None = ..., default: Any | None = ..., labelProperties=...): ...
    def comment(self, subject, default: str = ...): ...
    def items(self, list) -> Generator[Any, None, None]: ...
    def transitiveClosure(self, func, arg, seen: Any | None = ...) -> Generator[Any, None, None]: ...
    def transitive_objects(self, subject, predicate, remember: Any | None = ...) -> Generator[Any, None, None]: ...
    def transitive_subjects(self, predicate, object, remember: Any | None = ...) -> Generator[Any, None, None]: ...
    def seq(self, subject): ...
    def qname(self, uri): ...
    def compute_qname(self, uri, generate: bool = ...): ...
    def bind(self, prefix, namespace, override: bool = ..., replace: bool = ...): ...
    def namespaces(self) -> Generator[Any, None, None]: ...
    def absolutize(self, uri, defrag: int = ...): ...
    @overload
    def serialize(self, destination: None, format: str, base: Optional[str], encoding: str, **args) -> bytes: ...
    @overload
    def serialize(self, destination: None = ..., format: str = ..., base: Optional[str] = ..., encoding: None = ..., **args) -> str: ...
    @overload
    def serialize(self, destination: Union[str, pathlib.PurePath, IO[bytes]], format: str = ..., base: Optional[str] = ..., encoding: Optional[str] = ..., **args) -> Graph: ...
    @overload
    def serialize(self, destination: Optional[Union[str, pathlib.PurePath, IO[bytes]]] = ..., format: str = ..., base: Optional[str] = ..., encoding: Optional[str] = ..., **args) -> Union[bytes, str, 'Graph']: ...
    def print(self, format: str = ..., encoding: str = ..., out: Any | None = ...) -> None: ...
    def parse(self, source: Any | None = ..., publicID: Any | None = ..., format: Optional[str] = ..., location: Any | None = ..., file: Any | None = ..., data: Optional[Union[str, bytes, bytearray]] = ..., **args): ...
    def load(self, source, publicID: Any | None = ..., format: str = ...): ...
    def query(self, query_object, processor: Union[str, query.Processor] = ..., result: Union[str, Type[query.Result]] = ..., initNs: Any | None = ..., initBindings: Any | None = ..., use_store_provided: bool = ..., **kwargs) -> query.Result: ...
    def update(self, update_object, processor: str = ..., initNs: Any | None = ..., initBindings: Any | None = ..., use_store_provided: bool = ..., **kwargs): ...
    def n3(self): ...
    def __reduce__(self): ...
    def isomorphic(self, other): ...
    def connected(self): ...
    def all_nodes(self): ...
    def collection(self, identifier): ...
    def resource(self, identifier): ...
    def skolemize(self, new_graph: Any | None = ..., bnode: Any | None = ..., authority: Any | None = ..., basepath: Any | None = ...): ...
    def de_skolemize(self, new_graph: Any | None = ..., uriref: Any | None = ...): ...
    def cbd(self, resource): ...

class ConjunctiveGraph(Graph):
    context_aware: bool
    default_union: bool
    default_context: Any
    def __init__(self, store: Union[Store, str] = ..., identifier: Optional[Union[Node, str]] = ..., default_graph_base: Optional[str] = ...) -> None: ...
    def __contains__(self, triple_or_quad): ...
    def add(self, triple_or_quad: Union[Tuple[Node, Node, Node, Optional[Any]], Tuple[Node, Node, Node]]) -> ConjunctiveGraph: ...
    def addN(self, quads: Iterable[Tuple[Node, Node, Node, Any]]): ...
    def remove(self, triple_or_quad): ...
    def triples(self, triple_or_quad, context: Any | None = ...) -> Generator[Any, None, None]: ...
    def quads(self, triple_or_quad: Any | None = ...) -> Generator[Any, None, None]: ...
    def triples_choices(self, triple, context: Any | None = ...) -> Generator[Any, None, None]: ...
    def __len__(self): ...
    def contexts(self, triple: Any | None = ...) -> Generator[Any, None, None]: ...
    def get_context(self, identifier: Optional[Union[Node, str]], quoted: bool = ..., base: Optional[str] = ...) -> Graph: ...
    def remove_context(self, context) -> None: ...
    def context_id(self, uri, context_id: Any | None = ...): ...
    def parse(self, source: Any | None = ..., publicID: Any | None = ..., format: Any | None = ..., location: Any | None = ..., file: Any | None = ..., data: Any | None = ..., **args): ...
    def __reduce__(self): ...

class Dataset(ConjunctiveGraph):
    __doc__: str
    default_context: Any
    default_union: Any
    def __init__(self, store: str = ..., default_union: bool = ..., default_graph_base: Any | None = ...) -> None: ...
    def __reduce__(self): ...
    def graph(self, identifier: Any | None = ..., base: Any | None = ...): ...
    def parse(self, source: Any | None = ..., publicID: Any | None = ..., format: Any | None = ..., location: Any | None = ..., file: Any | None = ..., data: Any | None = ..., **args): ...
    def add_graph(self, g): ...
    def remove_graph(self, g): ...
    def contexts(self, triple: Any | None = ...) -> Generator[Any, None, None]: ...
    graphs: Any
    def quads(self, triple_or_quad: Optional[Any] = ...) -> Generator[Any, None, None]: ...
    def __iter__(self) -> Generator[DatasetQuad, None, None]: ...

class QuotedGraph(Graph):
    def __init__(self, store, identifier) -> None: ...
    def add(self, triple: Tuple[Node, Node, Node]): ...
    def addN(self, quads: Iterable[Tuple[Node, Node, Node, Any]]) -> QuotedGraph: ...
    def n3(self): ...
    def __reduce__(self): ...

class Seq:
    def __init__(self, graph, subject) -> None: ...
    def toPython(self): ...
    def __iter__(self): ...
    def __len__(self): ...
    def __getitem__(self, index): ...

class ModificationException(Exception):
    def __init__(self) -> None: ...

class UnSupportedAggregateOperation(Exception):
    def __init__(self) -> None: ...

class ReadOnlyGraphAggregate(ConjunctiveGraph):
    graphs: Any
    def __init__(self, graphs, store: str = ...) -> None: ...
    def destroy(self, configuration) -> None: ...
    def commit(self) -> None: ...
    def rollback(self) -> None: ...
    def open(self, configuration, create: bool = ...) -> None: ...
    @overload
    def close(self) -> None: ...
    @overload
    def close(self, commit_pending_transaction: bool = ...) -> Any: ...
    def add(self, triple) -> ConjunctiveGraph: ...
    def addN(self, quads) -> None: ...
    def remove(self, triple) -> None: ...
    @overload
    def triples(self, triple) -> Generator[Any, None, None]: ...
    @overload
    def triples(self, triple_or_quad: Any, context: Optional[Any] = ...) -> Generator[Any, None, None]: ...
    def __contains__(self, triple_or_quad): ...
    def quads(self, triple_or_quad: Optional[Any] = ...) -> Generator[Any, None, None]: ...
    def __len__(self): ...
    def __hash__(self): ...
    def __cmp__(self, other): ...
    def __iadd__(self, other) -> None: ...
    def __isub__(self, other) -> None: ...
    def triples_choices(self, triple, context: Any | None = ...) -> Generator[Any, None, None]: ...
    def qname(self, uri): ...
    def compute_qname(self, uri, generate: bool = ...): ...
    @overload
    def bind(self, prefix, namespace, override: bool = ...) -> None: ...
    @overload
    def bind(self, prefix: Any, namespace: Any, override: bool = ..., replace: bool = ...) -> Any: ...
    def namespaces(self) -> Generator[Any, None, None]: ...
    def absolutize(self, uri, defrag: int = ...) -> None: ...
    def parse(self, source: Optional[Any] = ..., publicID: Optional[Any] = ..., format: Optional[Any] = ..., location: Optional[Any] = ..., file: Optional[Any] = ..., data: Optional[Any] = ..., **args: Any) -> Any: ...
    def n3(self) -> None: ...
    def __reduce__(self) -> Union[str, Tuple[Any, ...]]: ...

class BatchAddGraph:
    graph: Any
    def __init__(self, graph: Graph, batch_size: int = ..., batch_addn: bool = ...) -> None: ...
    batch: Any
    count: int
    def reset(self): ...
    def add(self, triple_or_quad: Union[Tuple[Node, Node, Node], Tuple[Node, Node, Node, Any]]) -> BatchAddGraph: ...
    def addN(self, quads: Iterable[Tuple[Node, Node, Node, Any]]): ...
    def __enter__(self): ...
    def __exit__(self, *exc) -> None: ...
